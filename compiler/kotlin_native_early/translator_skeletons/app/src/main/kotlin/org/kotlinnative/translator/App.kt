/*
 * This source file was generated by the Gradle 'init' task
 */
package org.kotlinnative.translator

import com.intellij.psi.PsiElement
import com.intellij.psi.PsiWhiteSpace
import com.intellij.psi.impl.source.tree.LeafPsiElement
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.psi.KtBinaryExpression
import org.jetbrains.kotlin.psi.KtBlockExpression
import org.jetbrains.kotlin.psi.KtConstantExpression
import org.jetbrains.kotlin.psi.psiUtil.getNextSiblingIgnoringWhitespaceAndComments

var llvmCode = LLVMBuilder()

var variableCount = 0
fun evaluateBinaryExpression(expr: KtBinaryExpression) : LLVMVariable {
    val left = evaluateExpression(expr.firstChild)
    val right = evaluateExpression(expr.lastChild)
    val operator = expr.operationToken

    val llvmOperator = when (operator) {
        KtTokens.PLUS -> "add nsw i32"
        KtTokens.MINUS -> "sub nsw i32"
        KtTokens.MUL -> "mul nsw i32"
        else -> throw UnsupportedOperationException()
    }

    variableCount++
    llvmCode.addLLVMCode("%var$variableCount = $llvmOperator ${left?.label}, ${right?.label}")
    return LLVMVariable("%var$variableCount")
}

fun evaluateReturnInstruction(element: LeafPsiElement) : LLVMVariable? {
    var next = element.getNextSiblingIgnoringWhitespaceAndComments()
    val retVar = evaluateExpression(next)
    llvmCode.addLLVMCode("ret i32 ${retVar?.label}")
    return null
}

fun evaluateLeafPsiElement(element: LeafPsiElement) : LLVMVariable? {
    return when (element.elementType) {
        KtTokens.RETURN_KEYWORD -> evaluateReturnInstruction(element)
        else -> LLVMVariable("")
    }
}
fun evaluatePsiElement(element: PsiElement) : LLVMVariable? {
    return when (element) {
        is LeafPsiElement -> evaluateLeafPsiElement(element)
        is KtConstantExpression -> evaluateConstantExpression(element)
        KtTokens.INTEGER_LITERAL -> null
        else -> null
    }
}
fun evaluateConstantExpression(expr: KtConstantExpression) : LLVMVariable {
    return LLVMVariable(expr.node.firstChildNode.text)
}
fun evaluateExpression(expr: Any?) : LLVMVariable? {
    return when (expr) {
        is KtBinaryExpression -> evaluateBinaryExpression(expr)
        is PsiWhiteSpace -> null
        is PsiElement -> evaluatePsiElement(expr)
        is KtConstantExpression -> evaluateConstantExpression(expr)
        null -> null
        else -> throw UnsupportedOperationException()
    }
}
fun evaluateBlockExpression(expr : KtBlockExpression) {
    expressionWalker(expr.firstChild)
    expressionWalker(expr.getNextSiblingIgnoringWhitespaceAndComments())
}

fun evaluatePsiExpression(expr : PsiElement) {
    evaluateExpression(expr.firstChild)
    evaluatePsiExpression(expr.getNextSiblingIgnoringWhitespaceAndComments() ?: return)
}
fun expressionWalker(expr : Any?) {
    when(expr) {
        is KtBlockExpression -> evaluateBlockExpression(expr)
        is PsiElement -> evaluatePsiExpression(expr)
        null -> Unit
        else -> UnsupportedOperationException()
    }
}

fun main() {
    val scriptFile = "/Users/bytedance/code/kindergarten/compiler/kotlin_native_early/translator_skeletons/sum.kt"
    val parser = KotlinScriptParser()
    val analyzerContext = parser.parse(scriptFile)

    val function = analyzerContext?.functions?.keys?.first()

    llvmCode.addLLVMCode("define i32 @${function.toString()}() #0{")
    val body = function?.let { it.bodyExpression as KtBlockExpression }
    expressionWalker(body)
    llvmCode.addLLVMCode("}")

    println(llvmCode)
}
